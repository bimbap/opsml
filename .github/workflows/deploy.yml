name: CI/CD to AWS EKS on Main Branch

on:
    push:
        branches:
            - main

jobs:
    build:
        name: Build and Push to ECR
        runs-on: ubuntu-latest
        steps:
            - name: Checkout code
              uses: actions/checkout@v3

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v2
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
                  aws-region: ${{ secrets.AWS_REGION }}

            - name: Login to Amazon ECR
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v1

            - name: Build, Tag, and Push Docker Image
              env:
                  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
                  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
              run: |
                  # Use commit SHA for versioning
                  SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-8)
                  # Also tag as latest
                  IMAGE_SHA="${ECR_REGISTRY}/${ECR_REPOSITORY}:${SHORT_SHA}"
                  IMAGE_LATEST="${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"

                  echo "Building images: ${IMAGE_SHA} and ${IMAGE_LATEST}"

                  docker build -t $IMAGE_SHA -t $IMAGE_LATEST .
                  docker push $IMAGE_SHA
                  docker push $IMAGE_LATEST

                  # Save the image tag for later use
                  echo "IMAGE_TAG=${SHORT_SHA}" >> $GITHUB_ENV

    deploy:
        name: Deploy to EKS
        runs-on: ubuntu-latest
        needs: build
        steps:
            - name: Checkout code
              uses: actions/checkout@v3

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v2
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
                  aws-region: ${{ secrets.AWS_REGION }}

            - name: Setup kubeconfig
              run: |
                  aws eks update-kubeconfig --name ${{ secrets.CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}

            - name: Update deployment image
              run: |
                  # Set the image in the deployment manifest
                  cd kubernetes
                  sed -i "s|image:.*|image: ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}|g" deploy.yaml

            - name: Delete old Kubernetes resources
              run: |
                  # Check if pods exists
                  kubectl get pods

                  # Delete existing resources
                  kubectl delete --ignore-not-found=true deploy.yaml
                  kubectl delete --ignore-not-found=true service.yaml

            - name: Deploy new version to EKS
              run: |
                  # Apply all manifests using kustomize
                  cd kubernetes
                  kubectl apply -k .

                  # Wait for deployment to be ready
                  kubectl rollout status deploy.yaml --timeout=300s

            - name: Display Service URL
              run: |
                  echo "Waiting for LoadBalancer to be ready..."
                  # Give AWS some time to provision the load balancer
                  sleep 30

                  # Get the external IP/hostname
                  EXTERNAL_IP=$(kubectl get service opsml-service -n opsml-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

                  echo "Application deployed successfully!"
                  echo "It may take a few minutes for the LoadBalancer to be fully operational"
                  echo "Service URL: http://${EXTERNAL_IP}"